// Generated by CoffeeScript 1.6.3
var assert, chai, datetime, root;

if (typeof require !== "undefined" && require !== null) {
  chai = require('chai');
  datetime = require('../datetime');
}

if (typeof GLOBAL === "undefined" || GLOBAL === null) {
  root = this;
} else {
  root = GLOBAL;
}

assert = chai.assert;

describe('datetime.parse', function() {
  describe('#strptime', function() {
    it('should return null when input is bogus', function() {
      var d;
      d = datetime.strptime('bogus input', '%Y-%m-%d');
      return assert.equal(d, null);
    });
    it('should parse full month name', function() {
      var d, idx, month, _i, _len, _ref, _results;
      _ref = datetime.MONTHS;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        month = _ref[idx];
        d = datetime.strptime("" + month + " 1 2013", '%B %D %Y');
        _results.push(assert.equal(d.getMonth(), idx));
      }
      return _results;
    });
    it('should parse full month case insensitively', function() {
      var d, idx, month, _i, _len, _ref, _results;
      _ref = datetime.MONTHS;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        month = _ref[idx];
        d = datetime.strptime("" + (month.toLowerCase()) + " 1 2013", '%B %D %Y');
        _results.push(assert.equal(d.getMonth(), idx));
      }
      return _results;
    });
    it('should parse short month name', function() {
      var d, idx, month, _i, _len, _ref, _results;
      _ref = datetime.MNTH;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        month = _ref[idx];
        d = datetime.strptime("" + month + " 1 2013", '%b %D %Y');
        _results.push(assert.equal(d.getMonth(), idx));
      }
      return _results;
    });
    it('should parse short month names case insensitively', function() {
      var d, idx, month, _i, _len, _ref, _results;
      _ref = datetime.MNTH;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        month = _ref[idx];
        d = datetime.strptime("" + (month.toLowerCase()) + " 1 2013", '%b %D %Y');
        _results.push(assert.equal(d.getMonth(), idx));
      }
      return _results;
    });
    it('should parse decimal seconds', function() {
      var d;
      d = datetime.strptime('2013-12-01 12:00:01.12', '%Y-%m-%d %H:%M:%f');
      assert.equal(d.getSeconds(), 1);
      return assert.equal(d.getMilliseconds(), 120);
    });
    it('should parse AM PM', function() {
      var d;
      d = datetime.strptime('2013-12-01 09:00 a.m.', '%Y-%m-%d %I:%M %p');
      assert.equal(d.getHours(), 9);
      d = datetime.strptime('2013-12-01 09:00 p.m.', '%Y-%m-%d %I:%M %p');
      return assert.equal(d.getHours(), 21);
    });
    it('should parse only with year (without date or month)', function() {
      var d;
      d = datetime.strptime("2013", '%Y');
      return assert.equal(d.getFullYear(), 2013);
    });
    return it('should parse only with short month names and year (without date)', function() {
      var d, idx, month, _i, _len, _ref, _results;
      _ref = datetime.MNTH;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        month = _ref[idx];
        d = datetime.strptime("" + month + " 2013", '%b %Y');
        _results.push(assert.equal(d.getMonth(), idx));
      }
      return _results;
    });
  });
  return describe('#isoparse()', function() {
    return it('should parse date in ISO format', function() {
      var d;
      d = datetime.isoparse('2013-09-01T16:00:00.00');
      d.setMinutes(d.getMinutes() + d.getTimezoneOffset());
      assert.equal(d.getFullYear(), 2013);
      assert.equal(d.getMonth(), 8);
      assert.equal(d.getHours(), 16);
      return assert.equal(d.getMinutes(), 0);
    });
  });
});
